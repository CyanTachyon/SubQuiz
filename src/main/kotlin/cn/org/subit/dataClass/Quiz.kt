package cn.org.subit.dataClass

import cn.org.subit.utils.ai.AI
import cn.org.subit.utils.ai.AiResponse
import kotlinx.serialization.*
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.nullable
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.CompositeDecoder.Companion.DECODE_DONE
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.random.Random
import kotlin.time.Duration.Companion.minutes

@OptIn(ExperimentalSerializationApi::class)
@Suppress("DEPRECATION_ERROR")
@Serializable(with = Quiz.Serializer::class)
@KeepGeneratedSerializer
data class Quiz<out Answer, out UserAnswer, out Analysis: String?>(
    val id: QuizId,
    val user: UserId,
    val time: Long,
    val duration: Long?,
    val sections: List<Section<Answer, UserAnswer, Analysis>>,
    val finished: Boolean,
    val correct: List<List<Boolean?>>?,
    val tokenUsage: AiResponse.Usage?,
)
{
    fun hideAnswer() = Quiz(
        id,
        user,
        time,
        duration,
        sections.map(Section<Answer,UserAnswer,Analysis>::hideAnswer),
        finished,
        correct,
        tokenUsage,
    )
    fun checkFinished(): Quiz<Answer, Any, Analysis>? =
        if (!finished) null
        else Quiz(
            id,
            user,
            time,
            duration,
            sections.map { it.checkFinished() ?: return null },
            true,
            correct,
            tokenUsage
        )

    fun withoutUserAnswer() =
        Quiz(
            id,
            user,
            time,
            duration,
            sections.map(Section<Answer, UserAnswer, Analysis>::withoutUserAnswer),
            finished,
            correct,
            tokenUsage,
        )

    fun <UA> mergeUserAnswer(o: Quiz<*, UA, *>): Quiz<Answer, UA, Analysis>
    {
        require(this.sections.size == o.sections.size) { "Sections size must be equal" }
        return Quiz(
            id,
            user,
            time,
            duration,
            sections.zip(o.sections).map { (a, b) -> a.mergeUserAnswer(b) },
            finished,
            correct,
            tokenUsage,
        )
    }

    companion object
    {
        val example = Quiz(
            QuizId(1),
            UserId(0),
            System.currentTimeMillis(),
            30.minutes.inWholeMilliseconds,
            listOf(Section.example),
            false,
            listOf(Section.example).map { it.questions.map { Random.nextBoolean() } },
            AiResponse.Usage(1, 2, 3),
        )
    }

    /**
     * The serializer for [Quiz].
     *
     * This serializer should theoretically behave in the same way as the one generated by the kotlinx plugin.
     * However, when writing this piece of code, there was a bug in the plugin
     * that prevented it from correctly handling generic-related serialization issues.
     * As a result, I manually wrote this serializer and submitted an issue.
     *
     * See [kotlinx.serialization Github](https://github.com/Kotlin/kotlinx.serialization/issues/2953)
     */
    @Deprecated("This serializer is only used to fix a bug in kotlinx.serialization, please do not use it.", level = DeprecationLevel.ERROR, replaceWith = ReplaceWith("Quiz.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)"))
    class Serializer<Answer, UserAnswer, Analysis: String?>(
        private val answerSerializer: KSerializer<Answer>,
        private val userAnswerSerializer: KSerializer<UserAnswer>,
        private val analysisSerializer: KSerializer<Analysis>
    ): KSerializer<Quiz<Answer, UserAnswer, Analysis>>
    {
        override val descriptor: SerialDescriptor = generatedSerializer(analysisSerializer, answerSerializer, userAnswerSerializer).descriptor

        private val idIndex = descriptor.getElementIndex("id")
        private val userIndex = descriptor.getElementIndex("user")
        private val timeIndex = descriptor.getElementIndex("time")
        private val durationIndex = descriptor.getElementIndex("duration")
        private val sectionsIndex = descriptor.getElementIndex("sections")
        private val finishedIndex = descriptor.getElementIndex("finished")
        private val correctIndex = descriptor.getElementIndex("correct")
        private val tokenUsageIndex = descriptor.getElementIndex("tokenUsage")

        override fun deserialize(decoder: Decoder): Quiz<Answer, UserAnswer, Analysis>
        {
            val d = decoder.beginStructure(descriptor)
            var bits = 0
            var id: QuizId? = null
            var user: UserId? = null
            var time: Long? = null
            var duration: Long? = null
            var sections: List<Section<Answer, UserAnswer, Analysis>>? = null
            var finished: Boolean? = null
            var correct: List<List<Boolean>>? = null
            var tokenUsage: AiResponse.Usage? = null

            loop@ while (true)
            {
                val i = d.decodeElementIndex(descriptor)
                when (i)
                {
                    DECODE_DONE -> break@loop
                    idIndex -> id = d.decodeSerializableElement(descriptor, idIndex, QuizId.serializer())
                    userIndex -> user = d.decodeSerializableElement(descriptor, userIndex, UserId.serializer())
                    timeIndex -> time = d.decodeLongElement(descriptor, timeIndex)
                    durationIndex -> duration = d.decodeSerializableElement(descriptor, durationIndex, Long.serializer().nullable)
                    sectionsIndex -> sections = d.decodeSerializableElement(descriptor, sectionsIndex, ListSerializer(Section.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)))
                    finishedIndex -> finished = d.decodeBooleanElement(descriptor, finishedIndex)
                    correctIndex -> correct = d.decodeSerializableElement(descriptor, correctIndex, ListSerializer(ListSerializer(Boolean.serializer())).nullable)
                    tokenUsageIndex -> tokenUsage = d.decodeSerializableElement(descriptor, tokenUsageIndex, AiResponse.Usage.serializer().nullable)
                    else -> throw SerializationException("Unknown index $i")
                }
                bits = bits or (1 shl i)
            }
            d.endStructure(descriptor)
            if (bits != 0b11111111)
            {
                if (bits and (1 shl idIndex) == 0) throw SerializationException("Missing id")
                if (bits and (1 shl userIndex) == 0) throw SerializationException("Missing user")
                if (bits and (1 shl timeIndex) == 0) throw SerializationException("Missing time")
                if (bits and (1 shl durationIndex) == 0) throw SerializationException("Missing duration")
                if (bits and (1 shl sectionsIndex) == 0) throw SerializationException("Missing sections")
                if (bits and (1 shl finishedIndex) == 0) throw SerializationException("Missing finished")
                if (bits and (1 shl correctIndex) == 0) throw SerializationException("Missing correct")
                if (bits and (1 shl tokenUsageIndex) == 0) throw SerializationException("Missing tokenUsage")
            }
            return Quiz(id!!, user!!, time!!, duration, sections!!, finished!!, correct, tokenUsage)
        }

        override fun serialize(encoder: Encoder, value: Quiz<Answer, UserAnswer, Analysis>)
        {
            val c = encoder.beginStructure(descriptor)
            c.encodeSerializableElement(descriptor, idIndex, QuizId.serializer(), value.id)
            c.encodeSerializableElement(descriptor, userIndex, UserId.serializer(), value.user)
            c.encodeLongElement(descriptor, timeIndex, value.time)
            c.encodeSerializableElement(descriptor, durationIndex, Long.serializer().nullable, value.duration)
            c.encodeSerializableElement(descriptor, sectionsIndex, ListSerializer(Section.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)), value.sections)
            c.encodeBooleanElement(descriptor, finishedIndex, value.finished)
            c.encodeSerializableElement(descriptor, correctIndex, ListSerializer(ListSerializer(Boolean.serializer().nullable)).nullable, value.correct)
            c.encodeSerializableElement(descriptor, tokenUsageIndex, AiResponse.Usage.serializer().nullable, value.tokenUsage)
            c.endStructure(descriptor)
        }
    }
}