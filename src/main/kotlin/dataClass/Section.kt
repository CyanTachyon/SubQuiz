package moe.tachyon.quiz.dataClass

import kotlinx.serialization.*
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.CompositeDecoder.Companion.DECODE_DONE
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

@OptIn(ExperimentalSerializationApi::class)
@Suppress("DEPRECATION_ERROR")
@Serializable(with = Section.Serializer::class)
@KeepGeneratedSerializer
data class Section<out Answer, out UserAnswer, out Analysis: String?>(
    val id: SectionId,
    val type: SectionTypeId,
    val description: String,
    val weight: Int,
    val available: Boolean,
    val markdown: Boolean,
    val questions: List<Question<Answer, UserAnswer, Analysis>>
)
{
    init
    {
        if (weight < 0 || weight > 100) throw IllegalArgumentException("Weight must be between 0 and 100")
        if (available && questions.isEmpty()) throw IllegalArgumentException("Questions must not be empty if available is true")
    }

    fun hideAnswer() = Section(
        id = id,
        type = type,
        description = description,
        weight = weight,
        available = available,
        markdown = markdown,
        questions  = questions.map { it.hideAnswer() }
    )

    fun checkFinished(): Section<Answer, Any, Analysis>? =
        Section(
            id = id,
            type = type,
            description = description,
            weight = weight,
            available = available,
            markdown = markdown,
            questions = questions.map { it.checkFinished() ?: return null }
        )

    fun withoutUserAnswer() =
        Section(
            id = id,
            type = type,
            description = description,
            weight = weight,
            available = available,
            markdown = markdown,
            questions = questions.map { it.withoutUserAnswer() }
        )

    fun <UA> mergeUserAnswer(o: Section<*, UA, *>): Section<Answer, UA, Analysis>
    {
        require(questions.size == o.questions.size) { "Questions size must be equal" }
        return Section(
            id = id,
            type = type,
            description = description,
            weight = weight,
            available = available,
            markdown = markdown,
            questions = questions.zip(o.questions).map { (a, b) -> a.mergeUserAnswer(b) }
        )
    }

    fun check(): Boolean = questions.all { it.check() }

    companion object
    {
        val example = Section(
            id = SectionId(1),
            type = SectionTypeId(1),
            description = "the section description",
            weight = 50,
            available = true,
            markdown = false,
            questions = Question.examples
        )
    }

    /**
     * The serializer for [Section].
     *
     * This serializer should theoretically behave in the same way as the one generated by the kotlinx plugin.
     * However, when writing this piece of code, there was a bug in the plugin
     * that prevented it from correctly handling generic-related serialization issues.
     * As a result, I manually wrote this serializer and submitted an issue.
     *
     * See [kotlinx.serialization Github](https://github.com/Kotlin/kotlinx.serialization/issues/2953)
     *
     * The old data does not include the fields `weight`, `available`, or `markdown`.
     * To ensure compatibility (prevent deserialization errors),
     * these three fields should be treated as optional during deserialization.
     */
    @Deprecated("This serializer is only used to fix a bug in kotlinx.serialization, please do not use it.", level = DeprecationLevel.ERROR, replaceWith = ReplaceWith("Section.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)"))
    class Serializer<Answer, UserAnswer, Analysis: String?>(
        private val answerSerializer: KSerializer<Answer>,
        private val userAnswerSerializer: KSerializer<UserAnswer>,
        private val analysisSerializer: KSerializer<Analysis>
    ): KSerializer<Section<Answer, UserAnswer, Analysis>>
    {
        companion object
        {
            private const val ELEMENT_COUNT = 8
            private const val FULL_BITS = (1 shl ELEMENT_COUNT) - 1
        }

        override val descriptor: SerialDescriptor = generatedSerializer(analysisSerializer, answerSerializer, userAnswerSerializer).descriptor

        private val idIndex = descriptor.getElementIndex("id")
        private val typeIndex = descriptor.getElementIndex("type")
        private val descriptionIndex = descriptor.getElementIndex("description")
        private val weightIndex = descriptor.getElementIndex("weight")
        private val availableIndex = descriptor.getElementIndex("available")
        private val markdownIndex = descriptor.getElementIndex("markdown")
        private val questionsIndex = descriptor.getElementIndex("questions")

        override fun deserialize(decoder: Decoder): Section<Answer, UserAnswer, Analysis>
        {
            val d = decoder.beginStructure(descriptor)
            var bits = 0
            var id: SectionId? = null
            var type: SectionTypeId? = null
            var description: String? = null
            var weight: Int = 50
            var available: Boolean = true
            var markdown: Boolean = false
            var questions: List<Question<Answer, UserAnswer, Analysis>>? = null
            loop@ while (true)
            {
                val i = d.decodeElementIndex(descriptor)
                when (i)
                {
                    DECODE_DONE -> break@loop
                    idIndex -> id = d.decodeSerializableElement(descriptor, i, SectionId.serializer())
                    typeIndex -> type = d.decodeSerializableElement(descriptor, i, SectionTypeId.serializer())
                    descriptionIndex -> description = d.decodeStringElement(descriptor, i)
                    weightIndex -> weight = d.decodeIntElement(descriptor, i)
                    availableIndex -> available = d.decodeBooleanElement(descriptor, i)
                    markdownIndex -> markdown = d.decodeBooleanElement(descriptor, i)
                    questionsIndex -> questions = d.decodeSerializableElement(descriptor, i, ListSerializer(Question.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)))
                    else -> throw SerializationException("Unknown index $i")
                }
                bits = bits or (1 shl i)
            }
            d.endStructure(descriptor)
            if (bits != FULL_BITS)
            {
                if (bits and (1 shl idIndex) == 0) throw SerializationException("Missing id")
                if (bits and (1 shl typeIndex) == 0) throw SerializationException("Missing type")
                if (bits and (1 shl descriptionIndex) == 0) throw SerializationException("Missing description")
                if (bits and (1 shl questionsIndex) == 0) throw SerializationException("Missing questions")

                @Suppress("ControlFlowWithEmptyBody")
                if (bits and (1 shl weightIndex) == 0) { /*do nothing*/ }
                @Suppress("ControlFlowWithEmptyBody")
                if (bits and (1 shl markdownIndex) == 0) { /*do nothing*/ }
                @Suppress("ControlFlowWithEmptyBody")
                if (bits and (1 shl availableIndex) == 0) { /*do nothing*/ }
            }
            return Section(
                id = id!!,
                type = type!!,
                description = description!!,
                weight = weight,
                available = available,
                markdown = markdown,
                questions = questions!!
            )
        }

        override fun serialize(encoder: Encoder, value: Section<Answer, UserAnswer, Analysis>)
        {
            val c = encoder.beginStructure(descriptor)
            c.encodeSerializableElement(descriptor, idIndex, SectionId.serializer(), value.id)
            c.encodeSerializableElement(descriptor, typeIndex, SectionTypeId.serializer(), value.type)
            c.encodeStringElement(descriptor, descriptionIndex, value.description)
            c.encodeIntElement(descriptor, weightIndex, value.weight)
            c.encodeBooleanElement(descriptor, availableIndex, value.available)
            c.encodeBooleanElement(descriptor, markdownIndex, value.markdown)
            c.encodeSerializableElement(descriptor, questionsIndex, ListSerializer(Question.serializer(answerSerializer, userAnswerSerializer, analysisSerializer)), value.questions)
            c.endStructure(descriptor)
        }
    }
}